/* Versão 1.0 Ardurrinho

Testes realizados
0 - 18/09/19
----------------

Programadores:
Mateus Alves
Matheus Araujo
----------------

Disponivel em: https://github.com/moohbr/ardurrinho/blob/master/mainduirno
*/

// Escolhe o que o motor irá fazer, de acordo com as distancias dos sensores
// Foi usado a logica de bits para definir os motores
// 00 = dois desligados
// 01 = Só da direita e por ai vai
void escolhe()
{
  if ((distancia1<50)&&(distancia2<50) // Se tiver perto dos dois sensores
  {
    escolhedor = 00 // para
  }
  if (distancia1<50)&&(distancia2>50) // Se tiver perto do sensor 1
  {
    escolhedor = 01 // vira a direita 
  }
  if (distancia1>50)&&(distancia2<50) // Se tiver perto do sensor 2
  {
    escolhedor = 10 // vira a esquerda
  }
  if (distancia1>50)&&(distancia2>50) // Nenhum sensor perto
  {
    escolhedor = 11 // Segue em frente
  }
}

// Conta o tempo que o sensor 1 recebeu echo (saber a distancia)
void conta1()
{
  tempo1 = pulseIn(PINO_ECHO_SENSOR1, HIGH) // Conta o tON de echo em microsegundos
  calcula1(); // Chama a função calcula, para calcular a distancia a partir do tempo
}

// Conta o tempo que o sensor 2 recebeu echo (saber a distancia)
void conta2()
{
  tempo2 = pulseIn(PINO_ECHO_SENSOR2, HIGH) // Conta o tON de echo em microsegundos
  calcula2();// Chama a função calcula, para calcular a distancia a partir do tempo
}

void pulsa_sensor1()
{
  digitalWrite(PINO_TRIGGER_SENSOR1, LOW);    // Desativa o pino 7, seguranca
  delayMicroseconds(5);                       // Ativa o delay
  digitalWrite(PINO_TRIGGER_SENSOR1, HIGH);   // Ativa o pino 7, triggando o sensor 1
  delayMicroseconds(10);                      // Ativa o delay necessario para o sensor reconhecer o trigger 
  digitalWrite(PINO_TRIGGER_SENSOR1, LOW);    // Desativa o pino 7, destriggando o sensor 1
  conta1();
}

void pulsa_sensor2()
{
  digitalWrite(PINO_TRIGGER_SENSOR2, LOW);    // Desativa o pino 4, seguranca 
  delayMicroseconds(5);                       // Ativa o delay 
  digitalWrite(PINO_TRIGGER_SENSOR2, HIGH);   // Ativa o pino 4, triggando o sensor 1
  delayMicroseconds(10);                      // Ativa o delay necessario para o sensor reconhecer o trigger 
  digitalWrite(PINO_TRIGGER_SENSOR2, LOW);    // Desativa o pino 4, destriggando o sensor 1
  conta2();
}

// A partir do tempo, calcula a distancia do objeto no sensor 1
void calcula1()
{
  tempo1/58      = distancia1  // em cm (formula fabricante)
}

// A partir do tempo, calcula a distancia do objeto no sensor 2
void calcula2()
{
  tempo2/58   = distancia2  // em cm (formula fabricante)

}

// Faz o motor seguir para a esquerda
void motor_esquerda()
{
 analogWrite(PINO_VCC_MOTOR_ESQUERDO, velocidade) // Como a saida analogica, se controla a potencia do motor
 analogWrite(PINO_GND_MOTOR_ESQUERDO, 0) // Faz o motor seguir em sua rotação padrão, já que o 0 (nivel logico baixo/referencial) esta no GND do motor
 analogWrite(PINO_VCC_MOTOR_DIREITO, 0) // Faz o motor seguir em sua rotação ao contraria (da padrão), já que o 0 (nivel logico baixo/referencial) esta no VCC do motor
 analogWrite(PINO_GND_MOTOR_DIREITO, velocidade) // Como a saida analogica, se controla a potencia do motor
}

// Faz o motor seguir para a direita
void motor_direita()
{
 analogWrite(PINO_VCC_MOTOR_ESQUERDO, 0) // Faz o motor seguir em sua rotação ao contraria, já que o 0 (nivel logico baixo/referencial) esta no VCC do motor
 analogWrite(PINO_GND_MOTOR_ESQUERDO, velocidade) // Como a saida analogica, se controla a potencia do motor
 analogWrite(PINO_VCC_MOTOR_DIREITO, velocidade) // Como a saida analogica, se controla a potencia do motor
 analogWrite(PINO_GND_MOTOR_DIREITO, 0) // Faz o motor seguir em sua rotação padrão, já que o 0 (nivel logico baixo/referencial) esta no GND do motor
}

// Faz o motor seguir para a frente
void motor_frente()
{
 analogWrite(PINO_VCC_MOTOR_ESQUERDO, velocidade) // Como a saida analogica, se controla a potencia do motor
 analogWrite(PINO_GND_MOTOR_ESQUERDO, 0) // Faz o motor seguir em sua rotação padrão, já que o 0 (nivel logico baixo/referencial) esta no GND do motor
 analogWrite(PINO_VCC_MOTOR_DIREITO, velocidade) // Como a saida analogica, se controla a potencia do motor
 analogWrite(PINO_GND_MOTOR_DIREITO, 0) // Faz o motor seguir em sua rotação padrão, já que o 0 (nivel logico baixo/referencial) esta no GND do motor
}

// Faz o motor parar
void motor_para()
{
 analogWrite(PINO_VCC_MOTOR_ESQUERDO, 0) // Como a saida analogica, se controla a potencia do motor. Nesse caso, está parado
 analogWrite(PINO_GND_MOTOR_ESQUERDO, 0) // Faz o motor seguir em sua rotação padrão, já que o 0 (nivel logico baixo/referencial) esta no GND do motor
 analogWrite(PINO_VCC_MOTOR_DIREITO, 0) // Como a saida analogica, se controla a potencia do motor. Nesse caso, está parado
 analogWrite(PINO_GND_MOTOR_DIREITO, 0) // Faz o motor seguir em sua rotação padrão, já que o 0 (nivel logico baixo/referencial) esta no GND do motor
}

// Faz o motor rodar ao contrario
void motor_re()
{
 analogWrite(PINO_VCC_MOTOR_ESQUERDO, 0) // Faz o motor seguir em sua rotação ao contraria, já que o 0 (nivel logico baixo/referencial) esta no VCC do motor
 analogWrite(PINO_GND_MOTOR_ESQUERDO, velocidade) // Como a saida analogica, se controla a potencia do motor
 analogWrite(PINO_VCC_MOTOR_DIREITO, 0) // Faz o motor seguir em sua rotação ao contraria, já que o 0 (nivel logico baixo/referencial) esta no VCC do motor
 analogWrite(PINO_GND_MOTOR_DIREITO, velocidade) // Como a saida analogica, se controla a potencia do motor
}

void setup() 
{
// Bibliotecas

  
// Define's para a escrita do codigo ficar mais legivel e facil
#define PINO_TRIGGER_SENSOR1     02 // TRIGGER PRECISA ENVIAR +VCC PARA O SENSOR DURANTE 10us
#define PINO_ECHO_SENSOR1        04 // ECHO PRECISA RECEBER A ONDA EM PWM COM O TEMPO(DISTANCIA) DO OBJETO
#define PINO_TRIGGER_SENSOR2     07 // TRIGGER PRECISA ENVIAR +VCC PARA O SENSOR DURANTE 10us
#define PINO_ECHO_SENSOR2        08 // ECHO PRECISA RECEBER A ONDA EM PWM COM O TEMPO(DISTANCIA) DO OBJETO
#define PINO_VCC_MOTOR_ESQUERDO  03 // PARA CONTROLAR A POTENCIA DO MOTOR, NECESSITA DE UM PINO COM PWM
#define PINO_VCC_MOTOR_DIREITO   05 // PARA CONTROLAR A POTENCIA DO MOTOR, NECESSITA DE UM PINO COM PWM
#define PINO_GND_MOTOR_ESQUERDO  06 // PARA CONTROLAR A POTENCIA DO MOTOR, NECESSITA DE UM PINO COM PWM
#define PINO_GND_MOTOR_DIREITO   09 // PARA CONTROLAR A POTENCIA DO MOTOR, NECESSITA DE UM PINO COM PWM

// Configurar as portas como entrada e saídas
pinMode(PINO_TRIGGER_SENSOR1, OUTPUT); // Ativa o pino 7 como saída (ativa o sensor/trigger)
pinMode(PINO_ECHO_SENSOR1,     INPUT); // Ativa o pino 6 como entrada (conta o tempo/echo)
pinMode(PINO_TRIGGER_SENSOR2, OUTPUT); // Ativa o pino 4 como saída (ativa o sensor/trigger)
pinMode(PINO_ECHO_SENSOR2,     INPUT); // Ativa o pino 5 como entrada (conta o tempo/echo)

// Ativar interrupção
attachInterrupt(digitalPinToInterrupt(PINO_ECHO_SENSOR1), borda_sensor1, CHANGE); // Ativa interrupção no sensor 1
attachInterrupt(digitalPinToInterrupt(PINO_ECHO_SENSOR2), borda_sensor2, CHANGE); // Ativa interrupção no sensor 2

// Variaveis auxiliares
int tempo1       = 0;      // Variavel para receber o tempo que o ECHO ficou ativo no sensor 1
int tempo2       = 0;      // Variavel para receber o tempo que o ECHO ficou ativo no sensor 2
int velocidade   = 0;      // Variavel para determinar a velocidade a qual os motores rodarao
float distancia1 = 0;      // Variavel para receber a distancia do objeto do sensor 1
float distancia2 = 0;      // Variavel para receber a distancia do objeto do sensor 2
int escolhedor   = 0;      // Variavel para escolher o que os motores irão fazer
}

void loop() 
{
 pulsa_sensor1();
 pulsa_sensor2();
 escolhe();
 
 switch (escolhedor) // de acordo com o numero recebido na função escolhe, toma-se a decisão, indicando os passos do motor.
 {
   case 00
   motor_para();
   delay(500);
   motor_re();
   break
   
   case 01
   motor_direita();
   break
   
   case 10
   motor_esquerda();
   break
   
   case 11
   motor_frente();
   break
 }
    
}
